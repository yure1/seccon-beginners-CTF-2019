# [Reversing] Leakage
elfファイルをデバッガを用いて、解析する問題です。  

問題URL：https://score.beginners.seccon.jp/files/leakage_80a8c3c2bd63254a033ea21093944b1e.tar.gz  
6月前半まで。  
*技術用語：アセンブリ言語、デバッガ、逆アセンブラ*

## 解答例
1. tarコマンドで対象ファイルを解凍する。
~~~
tar -xvf ファイル名
~~~
2. fileコマンドで、解凍されたファイルの種類が、elfファイルであることを確認する。
~~~
file leakage
~~~
3. 逆アセンブラをするソフトを用いて、処理の内容を把握する。
3. is_correct関数の初めの分岐を真とするflagの文字列を作成する。
3. ステップ実行ができるデバッガ(gdb etc.)を用いて、正解となる文字列を探しflag取得。

## 詳細
### 0. この問題について
Seccompareと同様、処理の内容をゴリゴリ読んでいきたいところですが、今回出現するconvert関数を解読することは、非常に骨が折れそうです。  
そこで、gdbなどのデバッガを用いて1文字ずつ解読を目指します。

### 1～2. 準備
問題URLよりダウンロードしてきたファイルは、tar.gzファイルですのでまず解凍します。
~~~
$ tar -xvf ファイル名
~~~
次に、fileコマンドを用いて、解凍されたファイルの種類を確認したところ、elfファイルのようです。
~~~
$ file leakage
leakage: ELF 64-bit LSB executable, x86-64,～
~~~
elfファイルを実行してみます。
~~~
$ ./leakage
usage: ./leakage flag
~~~
上記のようなエラーがでるので、使用例に基づいて適当な文字列でもう一度実行してみます。
~~~
$ ./leakage ctf4b{sample}
wrong
~~~
もちろん間違っていたので、逆アセンブルしていきます。

### 3～4. 処理内容の把握
今回逆アセンブルで使用するソフトは、IDAのフリーウェア版です。  

leakageをIDAで開き、まずはmain関数を見ていきます。  
<img width="525" alt="1" src="https://user-images.githubusercontent.com/51044014/58758873-f4ad6300-855c-11e9-951c-a16326763860.png">  
大雑把な流れとして、
1. コマンドライン引数が1つ以下の場合(./leakageしかない)は、`usage: ./leakage flag`を出力し、プログラムを終了する。
1. コマンドライン引数が1つより多い場合は、`loc_400697`に遷移する。
1. `loc_400697`内の`is_correct`関数の戻り値について、
    1. 0であるならば、`wrong`を出力する。
    1. 0以外であるならば、`correct`を出力する。
1. プログラムを終了する。  
となっています。  
このプログラムの`correct`を得るためには、`is_correct`関数が肝になるようです。  

そこで、次に`is_correct`関数を見に行きます。  
最初の部分の抜粋を以下に示します。  
<img width="396" alt="2" src="https://user-images.githubusercontent.com/51044014/58759081-99c93b00-855f-11e9-8f8e-18d1fe0afd7b.png">  
`is_correct`関数はまず、コマンドライン引数の文字列の長さを`strlen`関数で取得し、`0x22(=34)`と比較しています。  
一致した場合は、`loc_40060C`へ、しなかった場合は戻り値を0として`is_correct`関数を終了します。  
`is_correct`関数の戻り値が0の場合は、`wrong`が出力されてしまうので、`loc_40060C`に到達することを考えます。  
そこで、flag文字列の長さは34byte、アルファベットなので34文字だろうと推測することができます。  

無事`loc_40060C`に到達した際は、[rbp+var4]という場所に0を代入し、`loc_400653`に遷移します。  
ここで、後から分かることですが、[rbp+var4]に格納されている値は、ループのカウンタの役割をしています。  


次に、`loc_400653`をみます。  
<img width="390" alt="3" src="https://user-images.githubusercontent.com/51044014/58759195-0d1f7c80-8561-11e9-91a2-ff9ad34d8821.png">  
まず、[rbp+var4]に格納されている値と0x21(=33)と比較し、0x21より小さいか等しい場合は`loc_400615`に遷移します。    
`loc_400615`では、詳細は分かりませんが`convert`関数によって得られた文字と、コマンドライン引数の[rbp+var4]番目の文字を比較します。    
一致していれば、`loc_40064F`に遷移し、[rbp+var4]に1を加えて、`loc_400653`に戻ることでループを継続します。  
一致していなければ、0を戻り値としてis_correct関数を終了します。  

ここで、`convert`関数の詳細が知りたくなったところですが、`convert`関数はひたすら長く私には意味が分かりませんでした…。  
ただ`convert`関数の戻り値は一度raxに保存されているようです。  
そこで、デバッガを用いてleakageをステップ実行し、raxの値を一つずつ確かめる、ということをしてみます。  

### 5. gdb-pedaを用いて、flag取得を目指す。
今回デバッガには、gdb-pedaを用います。  
まずは、gdb-pedaでleakageを開きます。  
以下、メモリの値は環境により異なる場合があります。
~~~
$ gdb ./leakage
~~~
次に、pdisasコマンドを用いて、メモリ上のどこにis_correct関数があるかを確認します。
~~~
gdb-peda$ pdisas is_correct
Dump of assembler code for function is_correct:
   0x00000000004005e7 <+0>:     push   rbp
   0x00000000004005e8 <+1>:     mov    rbp,rsp
（省略）
   0x000000000040062b <+68>:    call   0x4006d0 <convert>
   0x0000000000400630 <+73>:    mov    BYTE PTR [rbp-0x5],al
   0x0000000000400633 <+76>:    mov    eax,DWORD PTR [rbp-0x4]
（省略）
~~~
0x4005e7から`is_correct`関数が始まるようです。  
ただ今回ほしいのは、`convert`関数実行後のraxなので、0x400630にブレークポイントを設置し、raxの値を確認することにします。  
~~~
gdb-peda$ b *0x40062b
~~~
最後に、34文字の適当な文字列を用意して、準備完了です。  
`main`関数には今回は興味がないので、`run`でデバッグしていきます。
~~~
gdb-peda$ run ctf4b{012345678901234567890123456}
~~~
今回のプログラムは、文字列の比較を間違えると即時終了するようになっています。  
上記文字列の場合、`ctf4b{`まではあっているのでループが実行されますが、次の文字`0`で終了します。  
その際のraxを見ると`l`になっています。  
そこで、`0`を`l`に置換し、再び実行すると今度は`1`でループが終了します。  
その際のraxの値で`1`を置換し、ということを`correct`が表示されるまで繰り返せば、ようやくflag取得です。  

なお、ステップ実行はめんどくさいので、ある程度動きが分かったら`c`コマンドでデバッグすることをお勧めします。  
また、おそらくもっと楽な方法はあります（笑）
